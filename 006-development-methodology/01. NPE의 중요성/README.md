# NPE의 중요성

## 요약

- NPE는 NullPointException의 약어로, 선언한 객체즤 값이 없거나 null일 때 데이터를 읽으려고 시도할 때 발생하는 증상이다
- NPE의 문제점은 의미가 모호해서 파생적 에러가 발생하고 발견했을 때 디버깅이 어렵다
- 본래 컴파일러가 어떤 데이터를 읽든 안전하도록 자동으로 확인해주는 것이 목적이었으나, null 개념에 대한 유혹이 커서 만들어졌다
  - 이로 인해 지난 40년 동안 이러한 문제로 인해 입은 손실은 약 10억 달러정도라고 한다
- NPE의 대안은 sum type/tagged union 같은 null이 될 수 있는 변수는 따로 분류한다
- 자바의 경우,
  - 애초에 처음부터 null이 발생하지 않도록 코딩한다
  - 뒷단에 방어 로직이 있더라도 null을 파라미터로 넘기지 않는다
  - Chaining 메서드 호출을 자제해서 디버깅을 쉽게 한다

---

## NPE란?
- NullPointException의 약어로 선언한 객체의 값이 없거나 null일 때 데이터를 읽으려고 시도하는 증상
  - 그 객체에서 호출 가능한 메서드를 호출했을 때 발생
- 일반적으로 이런 증상이 발생하면 실행 중인 프로그램이 종료됨

### NPE의 문제점
- null 자체의 의미가 모호해서 파생적 에러 발생
- 발생 이후 디버깅이 어려움

### 10억 달러짜리 실수
- null 개념을 처음 도입한 토니 호어가 말하길, 원래 목표는 어떤 데이터를 읽든 항상 안전하도록 컴파일러가 자동으로 확인하는 것이었음
- 하지만 null을 집어 넣으려는 유혹을 이기지 못함, 이유는 그렇게 하는 것이 훨씬 쉬웠기 때문
- 이 결정으로 셀수 없는 오류, 보안 버그 그리고 시스템 다운을 야기함
- 지난 40년 동안 이러한 문제 때문에 입은 고통과 손해는 10억 달러로 추산

### 대안
####  `sum type`/`tagged union`: null이 될 수 있는 변수는 따로 분류
```dart
Animal dog = new Animal();  // 일반 포인터, 항상 값을 가리키고 있으며 null이 될 수 없음
Animal? cat = null;         // Nullable 포인터, 일단 null로 초기화
```
- 일반적인 포인터와 달리 nullable 포인터는 반드시 if를 통한 null 체크를 수행, 이를 어기면 컴파일러 단에서 오류내는 방식
```kotlin
print(dog.name);       // dog는 절대로 null이 되지 않으므로 마음껏 사용 가능

// cat은 nullable하므로 사용 전에 반드시 if를 통해 null 체크
// 이를 어기면 컴파일러 단에서 오류냄
if(null == cat) {
	// 잘못됨
} else {
	print(cat.name);
}
```
- 특정 포인터들만 nullable하게 하고, 그러한 포인터는 항상 null 체크하여 모든 null 포인터 참조 오류를 없애버릴 수 있음
- 스위프트, 러스트, 하스켈, 스칼라, 코틀린 등이 `sum type`을 가진 대표적 언어

#### Java에서 처리
- null로 인한 에러는 시간이 지날 수록 자기가 개발한 소스가 아닌 경우 디버깅하기 더 어려워짐
- null 발생이 오류가 아닐 수 있고, 오히려 참일 수 있음. 즉, null인 경우 또다른 어떤 의미를 내포하고 있는지 판단하기 어려움
- 따라서 애초에 처음부터 NPE가 발생하지 않도록 코딩해야 함
---
- 처음부터 null parameter를 넘기지 않는다
  - 뒷단에 방어 로직을 짜더라도 의미 없는 null은 파라미터로 넘기지 않음
- null 여부 비교 처리 추가
  - if문을 통해 null 체크
- Chaining 메서드 호출 자제
  - `객체.method1().method2()...` 방식의 호출 자제
  - 작성 코드량이 현저히 줄어드나, NPE 발생 시 디버깅이 어려움

## Reference

[개발자들의 영원한 숙제, 'NULL' 이야기](https://slowalk.com/2181)

[[일반]널 포인터: 10억 달러짜리 실수](https://pgr21.com/freedom/57633)
